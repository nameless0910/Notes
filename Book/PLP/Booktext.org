* Introduction
- 编译器本身是个机器语言程序,编译源程序为与之等价的目标程序后就隐退
- 解释器类似虚拟机,机器语言为高级程序设计语言
- Late binding 一个程序可以为自己生成新的代码片段,并且可以随后去执行它们(把有关程序实现的决策推迟到运行时才做)
- 编译性能更好(编译器可以保证 x 就在 49378,无论源程序何时引用 x,就可生成访问此位置的机器语言指令,解释器需要在每次访问 x 时去一个表格里查找它)
- 许多语言是混合形式,比如 Java,如果编译器非"机械翻译",中间目标文件与源文件没有很强相似性,还叫做编译语言(彻底的分析和非平凡的变换)
- 大部分解释性语言使用预处理器:去除注释和空白,将字符结组形成各种单词(关键字,标识符,数和符号) | 可能采用与宏汇编器类似的方式展开各种缩写,标记出各种高级语法结构{循环,子程序}
- Fortran
  - linker 链接不完全的机器语言程序和库例程
  - 库例程:硬件指令集合的扩充
  - 输出库例程包含了一个格式解释器
  - 类似解释器也出现在 C 及其后裔的 printf 例程
- 大部分编译器生成汇编语言,利于 debug,也利于将编译器隔离在机器语言文件格式之外,有利于移植到新的操作系统
- C 以及 Unix 下其他语言的编译器
  - 预处理器:删除注释和展开宏
    - 提供了 conditional compilation,能根据命令删除代码的一些部分
- 预编译器与编译器区别在于前者只基于模式匹配进行简单变换,而后者"理解"源码
- 早期 Pascal
  - 三个工具
    1. Pascal Complier,Output P-code
    2. Same Complier translate to P-code
    3. P-code interpreter use Pascal
  - 得到 Pascal 实现:bootstrap
    1. Translate P-code interpreter to some language could work
    2. Use P-code interpreter to run P-code Complier
    3. More fast,Change Pascal Complier to translate to assumbly language or machine instruction
- 支持大量 late binding 语言{Lisp,Prolog,Smalltalk}的编译器
  - 需要准备好生成一些代码,让它们去执行解释器的许多工作,或者调用一个库去完成这些工作
  - 对于一些重要的特殊情况,编译器也会生成一些代码,对运行前不能完成的决策做出一些合理的假设,假设成立代码会运行很快,假设错误,动态检查就会发现其中不协调的地方,并转到解释器处理
- 某些情况,程序设计系统会有意把编译推迟到尽可能晚的时间去做
  - Lisp 和 Prolog:运行中调用编译器,把新生成的代码编译,或者针对某个特定的输入集合做代码优化
  - Java:字节码,第一个 Java 实现基于字节码解释器,而更新的实现采用即时编译器,在程序具体执行前,即时编译器将它由字节码编译为机器语言
  - Csharp 的目标也是即时编译,主 Csharp 编译器生成 dotNET 的 CIL(Common Intermediate Language),在被执行前翻译成机器语言,CIL 强调语言无关性,可作为不同前端编译器生成的代码
  - 许多机器上,编译层指令并不真正翻译到硬件上,在微代码写成的解释器上运行
- [扫描器(词法分析)]->[分析器(语法分析)]->[语义分析和中间代码生成]->[与机器无关的代码优化(可选)]->[目标代码生成]->专门针对机器的代码改进(可选)]            |         [符号表]
          /                \          /           \                      /                                             \                                        /               \                   /            \                       /                        \
     字符流           单词流             语法分析树                                            抽象语法数或其他中间形式               修改后的中间格式      汇编/机器/其他                      修改后的中间格式
- 直至语法分析为前端,其他为后端
- Passes
- 扫描器读入一个个的字符,并将它们组合成单词,程序中最小的有意义的单位
  - 需要会生成一个表格,给各个单词做好行列位置标记
  - 语法分析树中根据具体的组成部分来表示各种高级结构(语句,表达式,子程序),每个结构是一个节点
  - 上下文无关法
- 语义分析 -> symbol table[data struction]
  - 标识符定义
  - 标识符上下文
  - 调用参数
  - switch 分支标号是否相同
  - 任一函数有非空的返回类型
- static semantics 
- dynamic semantics
  - 除非变量有值,否则不会再表达式使用
  - 除非指针指向合法的对象,否则不会被解引用
  - 数组下标表达式的值介于下标范围
  - 算术不会溢出

